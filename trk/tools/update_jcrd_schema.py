#!/usr/bin/env python3
"""
update_jcrd_schema.py - Update all JCRD files to match the new schema

This script processes all JSON files in the mcgill_jcrd directory and ensures they
follow the standardized structure with section support and forward compatibility.
"""

import os
import json
import logging
import argparse
from pathlib import Path
import sys
import re
from collections import defaultdict

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("update_jcrd_schema.log"),
        logging.StreamHandler(sys.stdout),
    ],
)

# Define the base schema structure
DEFAULT_SCHEMA = {
    "title": "",
    "artist": "",
    "bpm": 120,
    "key": "",  # New: estimated or fetched key
    "source": "",  # New: standardized data trace
    "beat_times": [],  # Optional global beat timing
    "sections": [],  # Array of section objects
}

# Default section structure
DEFAULT_SECTION = {
    "id": "",
    "start_ms": 0,
    "duration_ms": 0,
    "chords": [],
    "romanNumerals": [],  # New: harmony analysis
    "tags": ["autogenerated"],  # New: flexible tagging
}


def normalize_section_id(section_data, index, current_label=None):
    """Generate a normalized section ID based on section data."""
    # If the section has a label, use it to create a meaningful ID
    if "sectionLabel" in section_data:
        label = section_data["sectionLabel"].lower()
        return f"{label}_{index + 1}"

    # If a current label is provided (from SALAMI analysis)
    if current_label:
        return f"{current_label}_{index + 1}"

    # Default to section_N
    return f"section_{index + 1}"


def extract_section_type_from_tags(tags):
    """Extract section type from tags if it exists."""
    for tag in tags:
        if tag in [
            "verse",
            "chorus",
            "bridge",
            "intro",
            "outro",
            "instrumental",
            "pre-chorus",
            "interlude",
        ]:
            return tag
    return None


def normalize_chord_name(chord):
    """Normalize chord names to a standard format."""
    if not chord or chord == "N" or chord == "NC":
        return "N"  # No chord

    # Basic normalization, can be expanded for more complex cases
    return chord


def update_jcrd_file(file_path, dry_run=False):
    """Update a JCRD file to follow the new schema."""
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            data = json.load(f)

        # Track changes made to the file
        changes = []

        # Ensure all top-level fields exist
        for field, default_value in DEFAULT_SCHEMA.items():
            if field not in data:
                data[field] = default_value
                changes.append(f"Added missing field '{field}'")
            elif field == "beat_times" and not isinstance(data[field], list):
                data[field] = []
                changes.append(
                    f"Reset '{field}' to empty array (invalid format)"
                )

        # Special handling for source field
        if not data["source"]:
            data["source"] = "McGill Billboard"
            changes.append("Set default source to 'McGill Billboard'")

        # Update sections
        section_map = defaultdict(int)  # Track section counts by type

        for i, section in enumerate(data.get("sections", [])):
            # Ensure all section fields exist
            for field, default_value in DEFAULT_SECTION.items():
                if field not in section:
                    if field == "tags":
                        # Special handling for tags
                        tags = ["autogenerated"]

                        # Add section label as a tag if it exists
                        if "sectionLabel" in section:
                            tags.append(section["sectionLabel"])

                        section[field] = tags
                        changes.append(f"Added 'tags' to section {i+1}")
                    elif field == "romanNumerals":
                        section[field] = []
                        changes.append(
                            f"Added empty 'romanNumerals' array to section {i+1}"
                        )
                    else:
                        section[field] = default_value
                        changes.append(f"Added '{field}' to section {i+1}")

            # Normalize section ID
            section_label = section.get("sectionLabel", "")
            if section_label:
                section_map[section_label] += 1
                count = section_map[section_label]
                new_id = f"{section_label.lower()}_{count}"

                if section["id"] != new_id:
                    old_id = section["id"]
                    section["id"] = new_id
                    changes.append(
                        f"Updated section ID from '{old_id}' to '{new_id}'"
                    )

            # Add section label to tags if not already there
            if (
                "sectionLabel" in section
                and section["sectionLabel"] not in section["tags"]
            ):
                section["tags"].append(section["sectionLabel"])
                changes.append(
                    f"Added section label '{section['sectionLabel']}' to tags"
                )

            # Add sectionLetter to tags if it exists
            if (
                "sectionLetter" in section
                and f"form:{section['sectionLetter']}" not in section["tags"]
            ):
                section["tags"].append(f"form:{section['sectionLetter']}")
                changes.append(
                    f"Added section letter '{section['sectionLetter']}' to tags"
                )

            # Normalize chord names
            section["chords"] = [
                normalize_chord_name(chord) for chord in section["chords"]
            ]

        # If we made any changes, save the file
        if changes and not dry_run:
            with open(file_path, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=2)
            logging.info(f"Updated {file_path} with {len(changes)} changes")
            for change in changes:
                logging.debug(f"  - {change}")
        elif changes:
            logging.info(
                f"Would update {file_path} with {len(changes)} changes (dry run)"
            )
            for change in changes:
                logging.debug(f"  - {change}")

        return len(changes)
    except Exception as e:
        logging.error(f"Error updating {file_path}: {e}")
        return 0


def update_all_jcrd_files(directory, dry_run=False):
    """Update all JCRD files in a directory."""
    total_files = 0
    updated_files = 0
    error_files = 0

    for root, _, files in os.walk(directory):
        for filename in files:
            if filename.endswith(".json"):
                total_files += 1
                file_path = os.path.join(root, filename)

                try:
                    changes = update_jcrd_file(file_path, dry_run)
                    if changes > 0:
                        updated_files += 1
                except Exception as e:
                    logging.error(f"Failed to process {filename}: {e}")
                    error_files += 1

    logging.info(
        f"Processed {total_files} files: {updated_files} updated, {error_files} errors"
    )
    return updated_files, total_files


def main():
    parser = argparse.ArgumentParser(
        description="Update all JCRD files to match the new schema"
    )
    parser.add_argument(
        "--dry-run", action="store_true", help="Don't actually update files"
    )
    parser.add_argument(
        "--verbose", "-v", action="store_true", help="Enable verbose logging"
    )
    parser.add_argument(
        "--dir", type=str, help="Directory containing JCRD files"
    )
    parser.add_argument("--file", type=str, help="Single JCRD file to update")
    args = parser.parse_args()

    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    # Set paths
    script_dir = Path(__file__).parent

    if args.file:
        # Update single file
        file_path = Path(args.file)
        if not file_path.exists():
            logging.error(f"File not found: {file_path}")
            return 1

        changes = update_jcrd_file(file_path, args.dry_run)
        logging.info(f"Made {changes} changes to {file_path}")
    else:
        # Update all files in directory
        jcrd_dir = (
            Path(args.dir) if args.dir else script_dir.parent / "mcgill_jcrd"
        )

        if not jcrd_dir.exists():
            logging.error(f"Directory not found: {jcrd_dir}")
            return 1

        logging.info(f"Updating JCRD files in {jcrd_dir}")
        updated_files, total_files = update_all_jcrd_files(
            jcrd_dir, args.dry_run
        )

        # Print summary
        logging.info("=" * 80)
        logging.info(
            f"Summary: Updated {updated_files} of {total_files} files"
        )

    return 0


if __name__ == "__main__":
    sys.exit(main())
